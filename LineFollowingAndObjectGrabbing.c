#pragma config(StandardModel, "RVW CLAWBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Steven Killoran
//Lab03

void moveForwardWithEncoders();
void leftTurnWithEncoders();
void rightTurnWithEncoders();
void lineFollower(int upperPower, int lowerPower);

task main(){

	bool run = true;
	bool skippedStartLine = false; //this is just to skip the inital start box as it is also a black line.
	bool leftTurnFlag = false;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	motor[armMotor] = 105;//armMotor
	wait10Msec(10);
	motor[armMotor] = 0;

	while (SensorValue[sonarSensor] > 20 || SensorValue[sonarSensor] < 0 ){ //47
		//while(true){
		moveForwardWithEncoders();//moveForward(); // this keeps the left wheel from making the whole swerveBot drift left

		if(SensorValue[centerLineFollower]>1200){

			if(skippedStartLine == false){
				skippedStartLine = true;
				moveForwardWithEncoders();//moveForward();
				wait10Msec(20);
				continue;
			}

			if(leftTurnFlag == false && (SensorValue[centerLineFollower]>1300 && (SensorValue[sonarSensor] > 50 || SensorValue[sonarSensor] < 0)) ){
				motor[rightMotor] = 20;// the main controller for driving forwards
				motor[leftMotor] = 21;
				wait10Msec(100);
				leftTurnWithEncoders();//leftTurn();
			}

			lineFollower(70, 30);

			motor[rightMotor] = 0;// big left turn
			motor[leftMotor] = 0; //-125
			motor[clawMotor] = -25;
			motor[armMotor] = -105;//armMotor
			wait10Msec(300);
			motor[rightMotor] = -20;// big left turn
			motor[leftMotor] = -20; //-125
			motor[clawMotor] = 25;

			wait10Msec(50);
			motor[clawMotor] = 25;
			motor[armMotor] = 105;//armMotor
			wait10Msec(300);
			leftTurnWithEncoders();//leftTurn();
			leftTurnWithEncoders();//leftTurn();
			lineFollower(50, 10);

		}
	}
	rightTurnWithEncoders();//rightTurn();
	while (SensorValue[sonarSensor] > 50 || SensorValue[sonarSensor] < 0 ){
		motor[rightMotor] = 70;// left turn
		motor[leftMotor] = 70;

	}
	motor[rightMotor] = 0;// left turn
	motor[leftMotor] = 0;
	motor[armMotor] = -105;//armMotor
	wait10Msec(200);
	motor[clawMotor] = -25;
	wait10Msec(10);
}

void moveForwardWithEncoders(){
	//this will be an upgrade from the autocorrecting move forward i made in lab 1 using the gyro to trouble shoot my robot.
	//turns out this is actually called Automated Straightening... and more precise than something i could come up with using my limited knowlegde at the time!
	if(SensorValue[leftEncoder] == SensorValue[rightEncoder]){
		motor[leftMotor] = 100;
		motor[rightMotor] = 100;
	}else
		if(SensorValue[leftEncoder] > SensorValue[rightEncoder]){
		motor[leftMotor] = 95;
		motor[rightMotor] = 100;
		}else{
		//if(SensorValue[leftEncoder] < SensorValue[rightEncoder]){
		motor[leftMotor] = 100;
		motor[rightMotor] = 95;
	}
}

void leftTurnWithEncoders(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[rightEncoder] < 269){
		motor[rightMotor] = 60;
		motor[leftMotor] = -60;
	}
}

void rightTurnWithEncoders(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < 269){
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
	}
}

void lineFollower(int upperPower, int lowerPower){
	while(SensorValue[sonarSensor] > 30 || SensorValue[sonarSensor] < 0){//SensorValue[sonarSensor] > 30 || SensorValue[sonarSensor] < 0

		//if(SensorValue[rightLineFollower] <200 && SensorValue[leftLineFollower] <200){
		//	motor[rightMotor] = 80;//40
		//	motor[leftMotor] = 80;//40
		//}

		if(SensorValue[rightLineFollower]>1100/*1300*/ ){ //&& SensorValue[leftLineFollower]<200
			if(SensorValue[rightLineFollower]>2000){ //2200
				motor[rightMotor] = -65;// big right turn
				motor[leftMotor] = 65;
				wait10Msec(10);//20
				}else{
				motor[rightMotor] = lowerPower;//30;// right turn

				motor[leftMotor] = upperPower;//70;
			}
			//SensorValue[rightLineFollower]>2000 ||
			}else if(SensorValue[leftLineFollower]>1100 ){ //&& SensorValue[rightLineFollower]<200
			if(SensorValue[leftLineFollower]>2000){//2200
				motor[rightMotor] = 65;// big left turn
				motor[leftMotor] = -65; //-125
				wait10Msec(10);//20
				} else{
				motor[rightMotor] = upperPower;//70 left turn
				motor[leftMotor] = lowerPower;//30
			}
		}
		if(SensorValue[rightLineFollower] <200 && SensorValue[leftLineFollower] <200){
			motor[rightMotor] = 80;//40
			motor[leftMotor] = 80;//40
		}
	}
}
